验证器有两种类型：强或弱。若验证器容易生成但用于比较却没那么有用。强验证器用于对比很理想但难以（有时甚至不可能）有效生成。HTTP暴露使用中的验证器类型并限制若验证器可以用作先决条件的时机，而不是强制所有形式的资源都采用相同的验证器强度。

“强验证器”是一种表示元数据，无论是什么时候表示数据发生了改变它都会改变其值，这种改变可以在GET的200（OK）响应的负载体中观察到。

强验证器可能因很多原因而改变而不只是表示数据改变，例如当表示元数据语义重要的部分被改变（例如，Content-Type），当有必要使由远程缓存和创作工具持有的已存储响应无效时，只改变它的值对源服务器是最好的。

缓存实体可能持续任意长时间，而不管过期时间。因此，一个缓存可能试图验证一个使用在很久以前获得的验证器的实体。强验证器对一个特定资源是在所有版本的所有表示都是独一无二的。但是，在不同资源的表示中，并不存在唯一性的含义（即，相同的强验证器可能被同时用在多个资源的表示中并且不意味着那些资源是等价的）。

有很多种强验证器在实践中被使用。最好的是基于严格的校订控制，其中对表示的每个修改都产生一个独一无二的节点名和在表示可以被GET方式前被分配的校订标识符。如果在发送响应头字段之前数据是可用的，并且摘要不需要在每次接收到一个校验请求时重新计算，一个应用于表示数据的防碰撞哈希函数是足够的。但是，如果资源有仅元数据不同的表示，如可能发生在通过共享相同数据格式的媒体类型进行内容协商时，那么源服务器需要合并验证器中的额外信息已区分这些表示。

相反，“弱验证器”另一种表示元数据，它可能不会在表示数据每次改变时都改变。这种松懈可能是因为计算值的限制（如时钟分辨率），无法保证对资源所有可能表示的唯一性，或资源所有者希望通过一些自己确定的等价性而不是独特的数据序列来聚合表示的愿望。无论何时源服务器认为先前的表示不可接受为合适的当前表示是，源服务器**应该**改变弱实体标签。换句话说，无论何时源服务器想要缓存废除旧响应的时候，弱实体标签应该改变。

例如，一个基于动态测量每秒钟在内容上都有改变的天气预报的表示可能被分组到带有相同弱验证器的等价表示（从源服务器的角度）中，为了允许被缓存的响应在一个合理的时间段内有效（可能基于服务器负载或天气状况动态调整）。同样，如果以一秒的精度定义表示的修改时间，它可以是一个弱验证器，如果表示可能在一秒钟内被修改两次并在这两个修改之间被检索。

溶氧，如果被给定资源的两个或多个表示同时共享，这个验证器是弱验证器，除非那些表示有相同的表示数据。例如，如果源服务器对一个gzip内容编码的表示发送与无内容编码的表示相同的验证器，那么这个验证器是弱的。但是如果两个同步的表示只在表示元数据上有区别，他们可能共享相同的强验证器，就好像当两个不同的媒体类型对同样的表示数据都是可用的时候。

强验证器对所有条件请求都是可用的，包括缓存验证，部分内容范围，和“丢失更新”规避。弱验证器只在客户端不要求与先前获得的表示数据严格相等时可用，如当验证一个缓存实体或限制网络遍历到最近的变化。