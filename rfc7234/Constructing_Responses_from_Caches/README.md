当回应一个请求时，缓存**不得**使用已缓存的响应，除非：

- 呈现的有效请求URI（RFC7230，5.5节）和已存储响应的URI匹配，并且
- 与已存储响应关联的请求方法允许它被用于请求，并且
- 由已存储响应（如果有的话）指定的选择头字段匹配被呈现的那些（4.1节），并且
- 呈现的请求不包含no-cache参数（5.4节）或no-cache缓存指令（5.2.1节），除非已存储的响应被成功验证（4.3节），并且
- 已存储响应不包含no-cache缓存指令（5.2.2.2节），除非它被成功校验（4.3节），并且
- 已存储的响应：
  - 是新鲜的（4.2节），或
  - 允许被在过期的时候使用（4.2.4节），或
  - 成功的验证（4.3节）。

注意上面列出的任何要求都可以被cache-control扩展覆盖，查看5.2.3节。

当一个以缓存的响应被不经验证的用来满足一个请求时，缓存**必须**生成一个Age头字段（5.1节），它取代在响应中值等于已存储响应的当前生命，查看4.2.3节。

缓存**必须**通过对源服务器不安全的方法的请求进行写操作（RFC7231，4.2.1节）；即一个缓存是不允许在转发并接收到对应的响应之前对一个请求生成响应的。

同时也要注意，不安全请求可能使已存储的响应变得无效；查看4.4节。

当多个适当的响应被存储的时候，缓存**必须**使用最近响应（如由Date头字段确定）。它也使用“Cache-Control: max-age=0”或者“Cache-Control: no-cache”来转发请求以消除使用哪个响应的歧意。

没有可用时钟的缓存在每次使用缓存的时候**不得**在没有经过验证的情况下使用已存储的的响应。