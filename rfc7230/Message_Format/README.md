所有的HTTP/1.1消息都由以下部分组成。一个开始行；一个类似internet信息格式（RFC5322）的字节序列：零个或多个头字段（统称为头或头部）；一个空行指示头部分的结束；一个可选的消息体。

> ```
> HTTP-message   = start-line
>                  *( header-field CRLF )
>                  CRLF
>                  [ message-body ]
> ```

通常解析一个HTTP消息的步骤是将开始行读入一个结构体，将每个头字段读入一个哈希表直到出现一个空行，然后使用已解析的数据来确定是否期望一个消息体。如果消息体已经被指明，那么将以流的方式读取于消息体等长的字节序列或者直到连接被关闭。

接收者**必须**把一个HTTP消息解析为US-ASCII[USASCII]超集的编码中的八位字节序列。由于字符串处理库处理包含字节LF（％x0A）的无效多字节字符序列的方式不同，因此将HTTP消息解析为Unicode字符流（不考虑特定编码）会产生安全漏洞。基于字符串的解析器只由在从消息中提取出元素后才能安全的用于协议元素，例如在消息解析已经勾勒出单个字段的之后用于头字段的值上。

HTTP消息可以被解析为流以进行增量处理或下游转发。然而接收者不能依赖部分消息的增量转发，因为一些实现将会出于网络效率、安全检查、或有效负载转换的原因进行缓存或者延迟消息转发。

发送者**不得**在开始行和第一个头字段之间发送空白符。一个接收者收到开始行和第一个头字段之间的空白符**必须**将消息视为无效的进行拒绝或者丢弃每个空白前导的行而不继续处理(即忽略整行，连同任何后面的以空格开头的行，直到收到正确形成的标题字段或标题部分终止)

请求中这种空白的存在可能是企图欺骗服务器忽略该字段，或将该行之后的处理作为新的请求，无论哪种，如果请求链中的其他实现不同地解释相同的消息，都会导致安全漏洞。

同样的响应中的空白出现也会被一些客户端忽略或者造成停止解析。